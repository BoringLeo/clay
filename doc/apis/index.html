<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<link rel="shortcut icon" href="../images/clay.png" type="image/x-png">
	<title>clay - 文档</title>
	<link rel="stylesheet" href="../easycss-1.2.1.min.css">
	<link rel="stylesheet" href="../style.css">
	<link rel="stylesheet" href="./style.css">
	<script>
		function goto(target) {
			window.location.href = '#' + target;
		}
	</script>
</head>

<body>
	<header id='top'>
		clay v1.2.1
		<ul>
			<li>
				<a href="../index.html">首页</a>
			</li>
			<li>
				<a href="../examples/index.html">实例</a>
			</li>
			<li>
				<a href="./index.html" class='click'>文档</a>
			</li>
			<li>
				<a href="../aboutUs.html">加入我们</a>
			</li>
		</ul>
		<a href="https://github.com/yelloxing/clay" class="github">
			Fork me on GitHub
		</a>
	</header>
	<section>
		<ul>
			<li onclick='goto("characteristic")'>特色</li>
			<li onclick='goto("grammar")'>语法</li>
			<li onclick='goto("node")'>基本的结点操作</li>
			<li onclick='goto("node-search")' class='blank'>结点查找</li>
			<li onclick='goto("node-modify")' class='blank'>结点编辑</li>
			<li onclick='goto("node-data")' class='blank'>数据与结点</li>
			<li>工具类</li>
			<li class='blank'>轮播方法</li>
			<li class='blank'>色彩</li>
			<li class='blank'>最大值和最小值</li>
			<li>数学计算</li>
			<li class='blank'>Hermite三次插值</li>
			<li class='blank'>Cardinal三次插值</li>
			<li class='blank'>移动变换</li>
			<li class='blank'>缩放变换</li>
			<li class='blank'>旋转变换</li>
			<li>布局</li>
			<li class='blank'>树布局</li>
			<li class='blank'>力布局</li>
			<li>SVG绘图</li>
			<li class='blank'>扇形</li>
			<li class='blank'>曲线</li>
			<li>Canvas2D绘图</li>
			<li class='blank'>扇形</li>
			<li class='blank'>曲线</li>
		</ul>
		<article>
			<h1>
				clay - 提供更友好的数据可视化解决方案
			</h1>
			<p>
				通过提供一些基础的计算方法和绘图API，包括常用布局计算等接口，在不降低灵活性的前提下大大减小数据可视化实现的难度，便是我们的目的。
			</p>
			<p>
				如果通过使用clay，可以帮助你更快速的实现自己的创意，那caly的存在便充满了意义，祝你好运。
			</p>
			<h2 id='characteristic'>
				特色
			</h2>
			<ul>
				<li>完全自由的API设计，没有任何强制条件</li>
				<li>由于提供的只是基础接口，库文件本身非常小</li>
				<li>遵循MIT协议自由开源</li>
				<li>接口稳定，不同版本的升级，针对已有接口，只是性能优化</li>
				<li>跨浏览器实现</li>
			</ul>
			<h2 id='grammar'>
				语法
			</h2>
			<p>
				调用方式采用了链式调用的设计（部分工具类方法除外），可以分为二类。
			</p>
			<ul class='inner'>
				<li>
					第一类：结点集合对象（也就是clay对象），调用返回的对象和原来的对象是二个对象；
				</li>
				<li>
					第二类：非结点集合对象，调用返回的对象和原来的对象是同一个对象。
				</li>
			</ul>
			<p>
				请务必记住这二个区别，第二类返回和原来同一个对象的原因是在有些情况下，需要返回计算结果，可是传递新的参数获取的新对象也需要保留，就直接通过新旧对象一致实现了。
			</p>
			<h2 id='node'>
				基本的结点操作
			</h2>
			<p>
				关于结点的操作只提供非常必要的接口，这些接口已经可以满足日常工作需要；结点操作部分更核心的是数据和结点绑定问题，是为了方便数据到图形的操作，可以在
				<a href='../examples/index.html'>【实例】</a>
				中体会。
			</p>
			<h3 id='node-search'>
				结点查找
			</h3>
			<p>
				传递一个类似CSS选择器的字符串、结点或结点集合可以返回一个维护了很多结点的clay对象，这个过程就被称为结点查找，关于结点的操作都被挂载在这个clay对象上。
			</p>
			<pre class="code">var lis=clay('li.item');</pre>
			<p>
				上面通过传递一个选择器获取到了页面上所有class包含item的li结点。
			</p>
			<p id='selector'>
				传递的选择器目前包括下面几类：
			</p>
			<ul class='inner'>
				<li>
					第一类：id选择器、class选择器、属性选择器和元素选择器；
				</li>
				<li>
					第二类：以上选择器的任意组合（元素选择器最多一个，且必须在开头出现）；
				</li>
				<li>
					第三类：传递字符串*会查找全部元素；
				</li>
				<li>
					第四类：标签字符串，比如&lt;circle&gt;，标签的命名路径会自动获取，返回第一个结点。
				</li>
			</ul>
			<p>
				当然，如果不想在全局查找，可以传递第二个参数（类型是DOM结点）来规定查找上下文。
			</p>
			<span class="warn">
				温馨提示：需要注意的是，如果选择器字符串中存在id选择器，自动在全局查找，下同。
			</span>
			<pre class="code">var btns=lis.find('input[type="submit"]');</pre>
			<p>
				对于clay对象，可以调用find方法，把clay对象中维护的第一个结点作为上下文进行查找。
			</p>
			<pre class="code">var btn=btns.eq(2);</pre>
			<p>
				调用eq方法，比如上例，可以指定返回的clay对象维护的是第3个结点。
			</p>
			<h3 id='node-modify'>
				结点编辑
			</h3>
			<p>
				如果想操作clay对象中维护的结点，可以直接调用提供的兼容方法，部分接口是特定为了绘图而设计。
			</p>
			<pre class="code">btns.remove();</pre>
			<p>
				该方法用于在页面上删除btns中维护的全部结点。
			</p>
			<pre class="code" id='appendTo'>lis.appendTo('ul');</pre>
			<p>
				该方法会把lis维护的全部结点添加到所有指定元素的（这里是ul标签）内部结尾，这里查找元素的参数可以是任意一个之前提到的
				<a href="#selector">【合法选择器】</a>。
			</p>
			<p>
				上面二个都属于普通的元素操作，下面需要说明的是和下面一小节
				<a href="#node-data">【数据与结点】</a>
				有关的操作，主要为了简化绘图时的一些麻烦而特意设计的。
			</p>
			<pre class="code">$$('path').attr('stroke','red');</pre>
			<p>
				设置或获取属性值，上面的例子是设置path标签的轮廓线为红色，如果没有传递参数就是或许。
			</p>
			<p>
				除此之外，第二个参数还可以是一个函数，表示设置属性，函数的返回值作为属性新的值；该函数有二个参数，第一个参数是
				<a href="#node-data">【结点绑定】</a>
				的值，第二个参数代表clay对象中的序号，从0开始。
			</p>
			<pre class="code">$$('footer').css('font-size','16px');//$$是clay的简写，二者是等价的</pre>
			<p>
				与attr方法类似，除了普通的设置和获取样式值，第二个参数同样可以是一个函数，同上。
			</p>
			<p>
				设置的时候，你还可以传递一个JSON来设置多个值：
			</p>
			<pre class="code">
$$('footer').css({
    "height":"1rem",
    "width":"100%"
});</pre>
			<p>
				同样的，此刻你依旧可以传递一个函数，函数有四个参数，分别代表：结点绑定的数据、编号、样式名称和样式值，返回的值作为新的样式值。
			</p>
			<h3 id='node-data'>
				数据与结点
			</h3>
			<p>
				通过把数据和结点关联起来，比如在绘制饼状图的时候，每一个扇形的绘制或获取某个扇形对应的数据的时候只需要操作对应结点就可以了，在数据非常多的情况是有益的，大大减低了实现的复杂度。
			</p>
			<pre class="code">$$('path').datum(10);</pre>
			<p>
				上面语句是把查找到的所有path标签绑定数据为10，当然也可以再传递一个函数作为第二个函数，传递的函数有一个参数，此处该参数的值就是10，函数的返回值将作为结点绑定的值。
			</p>
			<p>
				如果什么参数都不传递，将返回维护的第一个结点绑定的数据。
			</p>
			<pre class="code">var updates=$$('path').data([10,9,4,8]);</pre>
			<p>
				该方法和datum类似，不同的是其用于把一组数据绑定到一组结点或返回一组结点数据，比如这里是把10、9、4和8分别绑定到查找到的第一个path、第二个path，以此类推。
			</p>
			<p>
				很容易想到，需要绑定的数据和维护的结点个数不一定是相同的，这就存在一个问题：如何去平衡二者？答案就是接下来要说明的二个方法。
			</p>
			<pre class="code">var enters=updates.enter('path');</pre>
			<p>
				把过滤出来多于结点的数据部分变成结点返回，需要传递一个字符串来标明新创建元素是什么。
			</p>
			<p>
				用上面的例子解释：如果维护的结点个数少于数据个数，就会返回维护了由那些多余数据绑定到的path结点的clay对象，如果需要，使用前面提到的
				<a href="#appendTo">【appendTo】</a>
				方法挂载到页面去，这样就平衡了。
			</p>
			<pre class="code">var exits=updates.exit();</pre>
			<p>
				过滤出来多于数据的结点部分返回。
			</p>
		</article>
	</section>
	<footer>
		心叶 &copy;2007-2018 走一步，再走一步
		<a href="#top">回到顶部</a>
	</footer>
</body>
<script>
	window.setTimeout(function () {
		var target = /(#.*)/.exec(window.location.href + "");
		if (target) window.location.href = target[1];
	}, 200);
</script>

</html>
