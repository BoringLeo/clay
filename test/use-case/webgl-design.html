<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="shortcut icon" href="../../doc/images/clay.png" type="image/x-png">
    <script src="../libs/clay.js"></script>
    <script type='x-shader/x-vertex' id='shader-vs'>
        attribute vec4 position;
        attribute float size;
        //uniform vec4 transform;
        uniform float sinB,cosB;
        void main(){
            //gl_Position=position+transform;
            //gl_Position=position;
            gl_Position.x=position.x*cosB-position.y*sinB;
            gl_Position.y=position.x*sinB+position.y*cosB;
            gl_Position.z=position.z;
            gl_Position.w=position.w;
            gl_PointSize=size;
        }
    </script>
    <script type='x-shader/x-fragment' id='shader-fs'>
        precision mediump float;
        uniform vec4 color;
        void main(){
            gl_FragColor=color;
        }
    </script>
    <title>WebGL 设计测试</title>
    <script>
        $$(function () {
            $$('<canvas>非常抱歉，您的浏览器不支持canvas!</canvas>')
                .appendTo('body')
                .attr('width', 700)
                .attr('height', 700);

            var gl = $$('canvas').webgl();

            var program = $$.webgl.useShaders(gl, $$('#shader-vs')[0].innerHTML, $$('#shader-fs')[0].innerHTML);

            // 获取attribute存储位置
            var position = gl.getAttribLocation(program, 'position');
            // 赋值
            gl.vertexAttrib3f(position, 0.0, 0.5, 0.0);

            var size = gl.getAttribLocation(program, 'size');
            gl.vertexAttrib1f(size, 5.0);

            gl.drawArrays(gl.POINTS, 0, 1);

            var color = gl.getUniformLocation(program, 'color');

            // var transform = gl.getUniformLocation(program, 'transform');

            // gl.uniform4f(transform, 0.1, 0.1, 0.0, 0.0);

            var sinB = gl.getUniformLocation(program, 'sinB');
            var cosB = gl.getUniformLocation(program, 'cosB');
            gl.uniform1f(sinB, Math.sin(Math.PI / 4));
            gl.uniform1f(cosB, Math.cos(Math.PI / 4));

            // 创建缓冲区对象
            var vertexBuffer = gl.createBuffer();
            if (!vertexBuffer) throw new Error('创建Buffer失败！');
            // 把缓冲区对象绑定到目标
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

            var ps = [], p;
            $$('canvas').bind('click', function (event) {
                event = event || window.event;
                p = $$(this).position(event);
                ps.push((p.x - 350) / 350);
                ps.push((350 - p.y) / 350);
                gl.uniform4f(color, p.x / 700, p.y / 700, 1.0, 1.0);

                // 向缓冲区中写入数据
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ps), gl.STATIC_DRAW);
                // 把缓冲区对象分配给目标变量
                gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
                // 连接目标对象和缓冲区对象
                gl.enableVertexAttribArray(position);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
            });

        });

    </script>
</head>

<body></body>

</html>
